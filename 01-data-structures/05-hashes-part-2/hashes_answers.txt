The def status method in Separate Chaining printed this when given the six Star Wars movies:

Load factor: 0.5, number of items in hash: 6.0
Key: Star Wars: The Empire Strikes Back, Value: Number Five
Key: Star Wars: Attack of the Clones, Value: Number Two
Key: Star Wars: Return of the Jedi, Value: Number Six
Key: Star Wars: A New Hope, Value: Number Four
Key: Star Wars: The Phantom Menace, Value: Number One
Key: Star Wars: Revenge of the Sith, Value: Number Three

In Open Addressing's `status` method I get this:

Number of items in hash: 6.0
Key: Star Wars: The Empire Strikes Back, Value: Number Five, Point in Array: 2
Key: Star Wars: Attack of the Clones, Value: Number Two, Point in Array: 3
Key: Star Wars: A New Hope, Value: Number Four, Point in Array: 4
Key: Star Wars: Return of the Jedi, Value: Number Six, Point in Array: 3
Key: Star Wars: The Phantom Menace, Value: Number One, Point in Array: 6
Key: Star Wars: Revenge of the Sith, Value: Number Three, Point in Array: 11

Three additional collision resolution strategies:

1. Random hashing - uses a random number generator that is seeded by the key to help determine the index value,
  if additional collisions occur, just use the next randomly generated value.

2. Hopscotch Hashing - A combination of cuckoo hashing and linear probing. If a collision happens the algorithm will
look for buckets near the original hash location and if none are found it will continue to look for one ultimately
using linear probing to continue down the line until an empty location is found. Then at this time it will repeatedly
displace items through a sequence of hops to bring the empty slot into the neighborhood of the original location.

3. Robin Hood Hashing - With this type of collision resolution strategy, when a collision occurs the hash will look
at the two objects and evaluate which one has a larger probe count and change the hash to reflect that data point.
This change would then effectively bump the object with the shorter search time out and cause that object to reallocate
itself. This ultimately leads to a reduction in the worst case search times for the table.

My Method:
When a collision occurs take the position found by the initial hashing strategy and make it negative to find a new
point that is that distance from the end of the table and then decrement backwards via negative linear probing.
